import os.path as osp
import warnings
import os
import shutil
import random
import json
from collections import defaultdict, OrderedDict
from .utils import read_json

class DataPreProcess:
    def __init__(self,):
        pass

    def preprocess(self,):
        pass

    def split_train_val_test(self, dataset_path, img_folder, seed, train_ratio=0.8, val_ratio=0.1, ):
        # This func applies to the image folders to be organized into the following structure:
        # =============
        # images/
        #     dog/
        #     cat/
        #     horse/
        # =============
        random.seed(seed)
        if os.path.exists(os.path.join(dataset_path, 'train')):
            print('Dataset has been splited, skip...')
            return
        images_dir = os.path.join(dataset_path, img_folder)
        for class_name in os.listdir(images_dir):
            cls_dir = os.path.join(images_dir, class_name)
            cls_img_list = os.listdir(cls_dir)
            random.shuffle(cls_img_list)
            cls_img_num = len(cls_img_list)
            num_train = int(cls_img_num * train_ratio)
            num_val = int(cls_img_num * val_ratio)
            splits = {'train': cls_img_list[:num_train],
                      'val': cls_img_list[num_train: (num_train+num_val)],
                      'test': cls_img_list[(num_train+num_val): ]}
            self.copy_files(dataset_path, img_folder, splits, class_name)
        print('Dataset train/val/test split complted!')


    def copy_files(self, dataset_path, img_folder, splits, class_name):
        for k, v in splits.items():
            os.makedirs(os.path.join(dataset_path, k), exist_ok=True)
            os.makedirs(os.path.join(dataset_path, k, class_name), exist_ok=True)
            for img_name in v:
                img_source = os.path.join(dataset_path, img_folder, class_name, img_name)
                img_target = os.path.join(dataset_path, k, class_name, img_name)
                shutil.copy(img_source, img_target)

    def save_split(self, train, val, test, path_prefix, test_path_prefix=None):


        train = self._extract(train, path_prefix)
        val = self._extract(val, path_prefix)
        test_path_pre  = test_path_prefix or path_prefix
        test = self._extract(test, test_path_pre)

        splits = {"train": train, "val": val, "test": test}
        self.copy_files_datum(splits, self.dataset_dir, self.image_dir)
        print('Dataset train/val/test split done!')

    def copy_files_datum(self, splits, dataset_dir, image_dir):
        """ This copy func is tailored for splits generated by Datam class.
        """
        for k, v in splits.items():
            print(f'Copying {len(v)} files for {k} split...')
            os.makedirs(os.path.join(dataset_dir, k), exist_ok=True)
            for img_info in v:
                img_name, cls_idx, cls_name = img_info[0], img_info[1], img_info[2]
                os.makedirs(os.path.join(dataset_dir, k, cls_name), exist_ok=True)
                img_source = os.path.join(image_dir, img_name)
                img_target = os.path.join(dataset_dir, k, cls_name, img_name)
                shutil.copy(img_source, img_target)

    def _extract(self, items, path_prefix):
        out = []
        for item in items:
            impath = item.impath
            label = item.label
            classname = item.classname
            impath = impath.replace(path_prefix, "")
            if impath.startswith("/"):
                impath = impath[1:]
            out.append((impath, label, classname))
        return out

    @property
    def class_names(self,):
        """ folder names of each class
        """
        train_dir = os.path.join(self.dataset_dir, 'train')
        return list(os.listdir(train_dir))

    @property
    def real_class_names(self,):
        """ real names of each classes
        """
        return None

    def read_split(self, filepath, path_prefix):
        def _convert(items):
            out = []
            for impath, label, classname in items:
                impath = os.path.join(path_prefix, impath)
                item = Datum(impath=impath, label=int(label), classname=classname)
                out.append(item)
            return out

        print(f"Reading split from {filepath}")
        split = read_json(filepath)
        train = _convert(split["train"])
        val = _convert(split["val"])
        test = _convert(split["test"])

        return train, val, test

    def split_trainval(self, trainval, p_val=0.2):
        p_trn = 1 - p_val
        print(f"Splitting trainval into {p_trn:.0%} train and {p_val:.0%} val")
        tracker = defaultdict(list)
        for idx, item in enumerate(trainval):
            label = item.label
            tracker[label].append(idx)

        train, val = [], []
        for label, idxs in tracker.items():
            n_val = round(len(idxs) * p_val)
            if n_val == 0:
                print(f'Number of samples are not enough!'
                      f'Class: {trainval[idxs[0]].classname}, num: {n_val} val data.')
            random.shuffle(idxs)
            for n, idx in enumerate(idxs):
                item = trainval[idx]
                if n < n_val:
                    val.append(item)
                else:
                    train.append(item)

        return train, val

    def read_classnames(self, text_file):
        """Return a dictionary containing
        key-value pairs of <folder name>: <class name>.
        """
        classnames = OrderedDict()
        with open(text_file, "r") as f:
            lines = f.readlines()
            for line in lines:
                line = line.strip().split(" ")
                folder = line[0]
                classname = " ".join(line[1:])
                classnames[folder] = classname
        return classnames

    def split_by_json(self, lower=False):
        with open(self.split_path, 'r') as f:
            jfile = json.load(f)
            splits = {
            'train': jfile['train'],
            'val': jfile['val'],
            'test': jfile['test']
            }
        self.copy_by_json(splits, lower=lower)


    def copy_by_json(self, splits, lower=False):
        for k, v in splits.items():
            os.makedirs(os.path.join(self.dataset_dir, k), exist_ok=True)
            print(f'Copying {len(list(v))} files for {k} split...')
            for img_info in v:
                img_path = img_info[0]
                if '/' in img_path:
                    img_name = img_path.split('/')[-1]
                else:
                    img_name = img_path
                cls_name = img_info[2]
                cls_name = cls_name.replace('_', ' ')
                cls_name = cls_name.replace('/', ' ')
                if lower:
                    cls_name = cls_name.lower()
                os.makedirs(os.path.join(self.dataset_dir, k, cls_name,), exist_ok=True)
                source = os.path.join(self.dataset_dir, self.img_folder, img_path)
                target = os.path.join(self.dataset_dir, k, cls_name, img_name)
                shutil.copy(source, target)
        print('Dataset train/val/test split complted!')

def check_isfile(fpath):
    """Check if the given path is a file.

    Args:
        fpath (str): file path.

    Returns:
       bool
    """
    isfile = osp.isfile(fpath)
    if not isfile:
        warnings.warn('No file found at "{}"'.format(fpath))
    return isfile


class Datum:
    """Data instance which defines the basic attributes.

    Args:
        impath (str): image path.
        label (int): class label.
        domain (int): domain label.
        classname (str): class name.
    """

    def __init__(self, impath="", label=0, domain=0, classname=""):
        assert isinstance(impath, str)
        assert check_isfile(impath)

        self._impath = impath
        self._label = label
        self._domain = domain
        self._classname = classname

    @property
    def impath(self):
        return self._impath

    @property
    def label(self):
        return self._label

    @property
    def domain(self):
        return self._domain

    @property
    def classname(self):
        return self._classname